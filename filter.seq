from bio import *
from cfg import *

# PCR Candidate filters, per k-mer

# Melting temp
# CG content
# di-nucleotide repeats > 4 dns
# consecutive runs > 4bp

# CG CONTENT
# note: kmer method gives uppercase, but sequences may be lowercase!
def cg_count(km):
	count = 0
	s = str(km).lower()
	count += s.count('c')
	count += s.count('g')
	return count

def cg_filter(km):
	cg = cg_count(km) / len(km)
	return cg >= MIN_CG and cg <= MAX_CG


# CG CLAMP
# Return True if NO CG clamp.
# A bit confusing, but consistent.
# Assumes given kmer is 5' -> 3'!
def clamp_filter(km):
	return cg_count(str(km)[-CG_CLAMP_LEN:]) > CG_CLAMP_MAX


# MELTING TEMP

# TM (wallace rule): Tm = 2AT + 4CG
# Return an estimate of melting temp. in celsius, according to wallace rule
def wallace_tm(km):
	cg = cg_count(km)
	at = len(km) - cg
	return 4*cg + 2*at

def tm_filter(km):
	tm = wallace_tm(km)
	return (tm >= MIN_TM) and (tm <= MAX_TM)


# REPEATS

bp_runs = ["a",	"c", "g", "t"]
dnr_repeats = [
	"aa", "ac", "ag", "at",
	"ca", "cc", "cg", "ct",
	"ga", "gc", "gg", "gt",
	"ta", "tc", "tg", "tt"
]

bp_runs = [x for x in map(lambda x: x*MAX_REPEATS, bp_runs)]
dnr_repeats = [x for x in map(lambda x: x*MAX_REPEATS, dnr_repeats)]
# map and lambda to make some repeated char sequences? wow

# Dinucleotide repeats
# return false if > MAX_REPEATS of some di-nucleotide consecutively
def dnr_filter(km):
	low = str(km).lower()
	for dnr in dnr_repeats:
		# return (False if dnr in low)
		if dnr in low:
			return False
	return True

# consecutive runs
# return False if a run > 5 bp of one base present in given kmer
def run_filter(km):
	low = str(km).lower()
	for run in bp_runs:
		# return (False if run in low)
		if run in low:
			return False
	return True


# ANNEALING

# Check for consecutive nt bonds between oligomers
def anneal_connected(s1, s2, k: Static[int]):
	# check bonding run of at least len k exists in 
	# complement or reverse complement of s2
	for seg in s1.kmers(k=k+1, step=1):
		if revcomp(seg) in s2 or reversed(revcomp(seg)) in s2:
			return False
	return True

# Helper for count_bonds
def check_bond(b1, b2):
	return (b1 == 'A' and b2 == 'T' or
			b1 == 'T' and b2 == 'A' or
			b1 == 'C' and b2 == 'G' or
			b1 == 'G' and b2 == 'C')
	
# Helper for anneal_disconnected
def count_bonds(s1, s2):
	count = 0
	for (b1, b2) in zip(s1, s2):
		if check_bond(b1, b2):
			count += 1
	return count

# Check for bond participation between oligomers above max
def anneal_disconnected(s1, s2):
	st1 = str(s1)
	st2 = str(s2)
	overlap_slices = []
	
	# get the before overlap slices
	for n in range( int(len(st2)/2), 1 ):
		overlap_slices.append(st2[n:])
	
	overlap_slices.append(st2)

	# Get the after overlap slices
	for n in range(len(st2), int(len(st2)/2)):
		overlap_slices.append(st2[:n])
	print(overlap_slices)

	for s in overlap_slices:
		if (count_bonds(st1, s)) / min(len(st1), len(st2)) > MAX_ANNEAL_BOND:
			return False
	return True

# Self-anneal filter
def sanneal_filter(km):
	return anneal_connected(km, km, MAX_CONS_SANNEAL) and anneal_disconnected(km, km)

# Cross-anneal filter
def xanneal_filter(km1, km2):
	return anneal_connected(km1, km2, MAX_CONS_XANNEAL) and anneal_disconnected(km1, km2)

# All Cs (per-kmer) filters
def all_filters(km):
	return (cg_filter(km) and 
			cg_filter(km) and 
			tm_filter(km) and 
			dnr_filter(km) and 
			run_filter(km) and
			sanneal_filter(km))


# print (anneal_disconnected(seq('ACGTACGTT'), seq('ACCGTACGT')))


def delta_tm(km1, km2):
	return abs(wallace_tm(km1) - wallace_tm(km2)) < MAX_DTM:

def at_tail():
	pass
	# TODO

def CG_clamp():
	pass
	# TODO? in the other one guess I did it wrong

def cross_anneal():
	pass
	# TODO