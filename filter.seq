from bio import *

# PCR Candidate filters

# Melting temp
# CG content
# di-nucleotide repeats > 4 dns
# consecutive runs > 4bp

# settings that should probably go elsewhere
MAX_REPEATS = 5
MIN_CG = 0.4
MAX_CG = 0.6
MIN_TM = 52
MAX_TM = 58

# CG CONTENT
# note: kmer method gives uppercase, but sequences may be lowercase!
def cg_count(km):
	count = 0
	s = str(km).lower()
	count += s.count('c')
	count += s.count('g')
	return count

def cg_filter(km):
	cg = cg_count(km) / len(km)
	return cg >= MIN_CG and cg <= MAX_CG


# MELTING TEMP

# TM (wallace rule): Tm = 2AT + 4CG
# Return an estimate of melting temp. in celsius, according to wallace rule
# TODO: 
# make sure this is right
# temp filter
def wallace_tm(km):
	cg = cg_content(km)
	at = len(km) - cg
	return 4*cg + 2*at

def tm_filter(km):
	tm = wallace_tm(km)
	return True if (tm >= MIN_TM) and (tm <= MAX_TM) else False


# REPEATS

bp_runs = ["a",	"c", "g", "t"]
dnr_repeats = [
	"aa", "ac", "ag", "at",
	"ca", "cc", "cg", "ct",
	"ga", "gc", "gg", "gt",
	"ta", "tc", "tg", "tt"
]

bp_runs = [x for x in map(lambda x: x*MAX_REPEATS, bp_runs)]
dnr_repeats = [x for x in map(lambda x: x*MAX_REPEATS, dnr_repeats)]
# map and lambda to make some repeated char sequences? wow

# dnr
# return false if > MAX_REPEATS of some di-nucleotide consecutively
def dnr_filter(km):
	low = str(km).lower()
	for dnr in dnr_repeats:
		return False if dnr in low
	return True

# consecutive runs
# return False if a run > 5 bp of one base present in given kmer
def run_filter(km):
	low = str(km).lower()
	for run in bp_runs:
		return False if run in low
	return True

# these could probably go together, whatever